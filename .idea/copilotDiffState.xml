<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/noponto/domain/services/OcorrenciaService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/noponto/domain/services/OcorrenciaService.kt" />
              <option name="updatedContent" value="package com.example.noponto.domain.services&#10;&#10;import android.net.Uri&#10;import com.example.noponto.domain.model.Ocorrencia&#10;import com.example.noponto.domain.repository.IOcorrenciaRepository&#10;import com.google.android.gms.tasks.Task&#10;import com.google.firebase.Timestamp&#10;import com.google.firebase.auth.FirebaseAuth&#10;import com.google.firebase.firestore.FirebaseFirestore&#10;import com.google.firebase.storage.FirebaseStorage&#10;import com.google.firebase.storage.UploadTask&#10;import kotlinx.coroutines.suspendCancellableCoroutine&#10;import kotlin.coroutines.resume&#10;import kotlin.coroutines.resumeWithException&#10;import java.util.UUID&#10;&#10;/**&#10; * Serviço de alto nível para operações de Ocorrencia.&#10; * - Faz upload do atestado (opcional) para Firebase Storage e salva apenas o path/URL no documento&#10; * - Valida inputs básicos antes de salvar&#10; */&#10;class OcorrenciaService(&#10;    private val repo: IOcorrenciaRepository,&#10;    private val auth: FirebaseAuth = FirebaseAuth.getInstance(),&#10;    private val firestore: FirebaseFirestore = FirebaseFirestore.getInstance(),&#10;    private val storage: FirebaseStorage = FirebaseStorage.getInstance()&#10;) {&#10;&#10;    private suspend fun &lt;T&gt; Task&lt;T&gt;.await(): T = suspendCancellableCoroutine { cont -&gt;&#10;        addOnSuccessListener { res -&gt; cont.resume(res) }&#10;        addOnFailureListener { ex -&gt; if (!cont.isCompleted) cont.resumeWithException(ex) }&#10;        addOnCanceledListener { if (!cont.isCompleted) cont.cancel() }&#10;    }&#10;&#10;    private suspend fun UploadTask.awaitUpload(): UploadTask.TaskSnapshot = suspendCancellableCoroutine { cont -&gt;&#10;        addOnSuccessListener { snap -&gt; cont.resume(snap) }&#10;        addOnFailureListener { ex -&gt; if (!cont.isCompleted) cont.resumeWithException(ex) }&#10;        addOnCanceledListener { if (!cont.isCompleted) cont.cancel() }&#10;    }&#10;&#10;    /**&#10;     * Faz upload do Uri para Storage e retorna a URL de download (String).&#10;     */&#10;    private suspend fun uploadAtestadoAndGetUrl(uid: String, uri: Uri): String {&#10;        val fileRef = storage.reference.child(&quot;atestados/$uid/${UUID.randomUUID()}&quot;)&#10;        val uploadTask = fileRef.putFile(uri)&#10;        uploadTask.awaitUpload()&#10;        val downloadUrl = fileRef.downloadUrl.await()&#10;        return downloadUrl.toString()&#10;    }&#10;&#10;    /**&#10;     * Cria e salva uma ocorrência a partir da UI. Se atestadoUri não for null, faz upload primeiro.&#10;     * dateStr: &quot;dd/MM/yyyy&quot; ; timeStr: &quot;HH:mm&quot;&#10;     */&#10;    suspend fun criarOcorrenciaFromUi(&#10;        justificativa: String,&#10;        dateStr: String,&#10;        timeStr: String,&#10;        atestadoUri: Uri? = null&#10;    ): Result&lt;String&gt; {&#10;        val user = auth.currentUser ?: return Result.failure(IllegalStateException(&quot;Usuário não autenticado&quot;))&#10;        val uid = user.uid&#10;        val funcRef = firestore.collection(&quot;funcionarios&quot;).document(uid)&#10;&#10;        if (justificativa.isBlank()) return Result.failure(IllegalArgumentException(&quot;Justificativa é obrigatória&quot;))&#10;&#10;        // fazer upload se houver atestado&#10;        val atestadoPath: String? = try {&#10;            if (atestadoUri != null) uploadAtestadoAndGetUrl(uid, atestadoUri) else null&#10;        } catch (e: Exception) {&#10;            return Result.failure(e) // falha no upload&#10;        }&#10;&#10;        val ocorr = Ocorrencia.createFromUi(&#10;            funcionarioId = uid,&#10;            funcionarioRef = funcRef,&#10;            funcionarioNome = user.displayName ?: &quot;&quot;,&#10;            justificativa = justificativa,&#10;            dateStr = dateStr,&#10;            timeStr = timeStr,&#10;            hasAtestado = atestadoPath != null,&#10;            atestadoStoragePath = atestadoPath&#10;        )&#10;&#10;        return repo.salvarOcorrencia(ocorr)&#10;    }&#10;&#10;    suspend fun atualizarOcorrencia(ocorrencia: Ocorrencia): Result&lt;Unit&gt; {&#10;        // valida básica&#10;        if (ocorrencia.justificativa.isBlank()) return Result.failure(IllegalArgumentException(&quot;Justificativa é obrigatória&quot;))&#10;        return repo.atualizarOcorrencia(ocorrencia)&#10;    }&#10;&#10;    suspend fun removerOcorrencia(ocorrenciaId: String): Result&lt;Unit&gt; = repo.removerOcorrencia(ocorrenciaId)&#10;&#10;    suspend fun buscarOcorrenciaPorId(ocorrenciaId: String): Result&lt;Ocorrencia?&gt; = repo.buscarOcorrenciaPorId(ocorrenciaId)&#10;&#10;    suspend fun listarUltimasOcorrencias(funcionarioId: String, limit: Int = 20): Result&lt;List&lt;Ocorrencia&gt;&gt; = repo.buscarUltimasOcorrencias(funcionarioId, limit)&#10;&#10;    suspend fun listarPorStatus(status: Ocorrencia.StatusOcorrencia, limit: Int = 50): Result&lt;List&lt;Ocorrencia&gt;&gt; = repo.listarPorStatus(status, limit)&#10;&#10;    suspend fun setStatus(ocorrenciaId: String, status: Ocorrencia.StatusOcorrencia): Result&lt;Unit&gt; = repo.setStatus(ocorrenciaId, status)&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>